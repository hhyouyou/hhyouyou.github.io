<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="djx">
  
  
  <!-- Open Graph Data -->
  <meta property="og:title" content="Java并发编程"/>
  <meta property="og:description" content="" />
  <meta property="og:site_name" content="Djx-blog"/>
  <meta property="og:type" content="article" />
  <meta property="og:image" content="http://dongjingxi.com"/>
  
    <link rel="alternate" href="/atom.xml" title="Djx-blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.ico">
  

  <!-- Site Title -->
  <title>Djx-blog</title>

  <!-- Bootstrap CSS -->
  
<link rel="stylesheet" href="/css/bootstrap.min.css">

  
<link rel="stylesheet" href="/css/font-awesome.min.css">

  <!-- Custom CSS -->
  
<link rel="stylesheet" href="/css/style.css">


  <!-- Google Analytics -->
  

  <!-- BaiDu Analytics -->
  



<meta name="generator" content="Hexo 4.2.0"></head>

  <body>
    <!-- Page Header -->


<nav class="navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse site-menu">
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="/">
                            
                                Home
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives">
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/about">
                            
                                About
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="mailto:<dongjingxiwin@outlook.com>">
                            
                                Email
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="https://github.com/hhyouyou" target="_blank" rel="noopener">
                            
                                <i class="icon fa fa-github fa-lg"></i>
                            
                        </a>
                    </li>
                
            </ul>
        </div>
    </div>
</nav>

<!-- Header -->
<header class="site-header header-background intro-header" style="background-image: url(http://image-djx.test.upcdn.net/blog/island.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">Java并发编程</p>
          <p class="subtitle"></p>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By djx</span>
          
          <!-- Date -->
          <span class="date-time info">On 
            <!-- <span class="date">2020-10-12T03:01:13+08:00</span> -->
            <span class="date">2020-10-12</span>
            <span class="time">00:23:10</span>
          </span>
          
        </div>
        <!-- Tags -->
        
        <!-- Post Main Content -->
        <div class="post-content">
          <p>[TOC]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">title: Java并发编程</span><br><span class="line">date: 2020-10-12 02:18:10</span><br><span class="line">tags: note</span><br></pre></td></tr></table></figure>



<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>这章准备整理一下，java线程相关的东西</p>
<h1 id="一、使用线程"><a href="#一、使用线程" class="headerlink" title="一、使用线程"></a>一、使用线程</h1><p>Java中使用线程的三种方式：</p>
<ul>
<li>继承 Thread 类</li>
<li>实现 Runnable 接口</li>
<li>实现 Callable 接口</li>
</ul>
<p>实现Runnable和Callable 接口的类只能当作一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以理解为任务是通过线程驱动从而执行的。</p>
<h2 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类"></a>继承 Thread 类</h2><p>同样也需要实现 run() 方法， 因为 Thread 类也实现了 Runnable 接口。</p>
<p>当我们调用start() 方法启动一个线程时， 虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getClass().getName());</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h2><p>需要实现 Runnable 接口中的 run() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h2><p>和Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread3</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getClass().getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.继承 Thread</span></span><br><span class="line">    Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread1(), <span class="string">"thread1"</span>);</span><br><span class="line">    thread1.start();</span><br><span class="line">    <span class="comment">// 2.实现 Runnable</span></span><br><span class="line">    Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread2(), <span class="string">"thread2"</span>);</span><br><span class="line">    thread2.start();</span><br><span class="line">    <span class="comment">// 3.实现 Callable</span></span><br><span class="line">    FutureTask&lt;String&gt; stringFutureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Thread3());</span><br><span class="line">    Thread thread3 = <span class="keyword">new</span> Thread(stringFutureTask, <span class="string">"thread3"</span>);</span><br><span class="line">    thread3.start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String s = stringFutureTask.get();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现接口-和-继承-Thread-类的对比"><a href="#实现接口-和-继承-Thread-类的对比" class="headerlink" title="实现接口  和  继承 Thread 类的对比"></a>实现接口  和  继承 Thread 类的对比</h2><p>实现接口相对更好：</p>
<ul>
<li>Java 支持单继承，多实现。实现接口更灵活</li>
<li>继承整个 Thread类开销更大</li>
</ul>
<h1 id="二、基础线程机制"><a href="#二、基础线程机制" class="headerlink" title="二、基础线程机制"></a>二、基础线程机制</h1><h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><p>Executor 管理多个异步任务的执行，而无需我们显式的管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。</p>
<p>主要有三种 Executor :</p>
<ul>
<li>CachedThreadPool: 一个任务创建一个线程</li>
<li>FixedThreadPool: 所有任务只能使用固定大小的线程池</li>
<li>SingleThreadExecutor: 只有一个线程的线程池</li>
</ul>
<h3 id="Executor-接口-及其-继承关系"><a href="#Executor-接口-及其-继承关系" class="headerlink" title="Executor 接口 及其 继承关系"></a>Executor 接口 及其 继承关系</h3><p><img src="http://image-djx.test.upcdn.net/md/notes/Executor%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="Executor类继承关系图"></p>
<ul>
<li><p><code>Executor</code>：是一个接口，定义了一个接受Runnable对象的方法executor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ExecutorService</code>: 是一个比<code>Executor</code> 使用更加广泛的子类接口，它提供了生命周期管理的方法，以及可以跟踪一个或多个异步任务执行状况返回<code>Future</code>的方法。shutdown()、submit()、invokeAll()等</p>
</li>
<li><p><code>AbstractExecutorService</code>: <code>ExecutorService</code>执行方法的默认实现`</p>
</li>
<li><p><code>ScheduledExecutorService</code>: 一个可定时调度任务的接口</p>
</li>
<li><p><code>ScheduledThreadPoolExecutor</code>: <code>ScheduledExecutorService</code>的实现，一个可定时调度任务的线程池。(这里还用了装饰者模式，装饰定时任务？没看懂)</p>
</li>
<li><p><code>ThreadPoolExecutor</code> : 表示一个线程池，可以通过<code>Executors</code>的静态工厂方法来创建一个拥有特定功能的线程池，并返回一个 <code>ExcutorService</code>对象。</p>
</li>
</ul>
<p>以上类、接口都在 <code>java.util.concurrent</code>包中，是JDK并发包的核心类。 其中 <code>ThreadPoolExecutor</code> 表示一个线程池。 <code>Executors</code> 类则扮演着线程池工厂的角色，通过<code>Executors</code>可以取得一个拥有特定功能的线程池。从UML图中也可以看到，<code>ThreadPoolExecutor</code> 类实现了<code>Executor</code> 接口， 因此，任何Runnable的对象都可以被<code>ThreadPoolExecutor</code>线程池调度。</p>
<h2 id="new-ThreadPoolExecutor-…"><a href="#new-ThreadPoolExecutor-…" class="headerlink" title="new ThreadPoolExecutor(…)"></a>new ThreadPoolExecutor(…)</h2><blockquote>
<p>线程资源必须通过线程池创建，不允许在应用内自行显示创建。——《阿里巴巴Java手册》</p>
</blockquote>
<h3 id="why"><a href="#why" class="headerlink" title="why"></a>why</h3><ol>
<li>降低开销。创建和销毁线程会产生很大的系统开销。</li>
<li>易复用和管理。将线程都放在一个公用的池子中，便于统一管理，也便于复用。</li>
<li>解耦。将线程的创建和销毁从业务代码中分离出来。便于维护。</li>
</ol>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,// 核心线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,// 线程池最大线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,// 空闲线程存活时间</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,// 时间单位</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,// 阻塞对列</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,// 线程工厂</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;<span class="comment">// 拒绝策略</span></span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?<span class="keyword">null</span> : AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="corePoolSize"><a href="#corePoolSize" class="headerlink" title="corePoolSize"></a>corePoolSize</h4><p>线程池中的核心线程数。提交一个任务到线程池时，会创建一个线程来执行任务，直到线程数等于corePoolSize就不再创建，此时继续提交的任务则会保存到阻塞对列中。如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有线程。</p>
<h4 id="maximumPoolSize"><a href="#maximumPoolSize" class="headerlink" title="maximumPoolSize"></a>maximumPoolSize</h4><p>线程池最大线程数，如果当前阻塞对列满了，继续提交任务，若当前线程数小于maximumPoolSize则创建新的线程执行任务。如果使用了无界的阻塞对列这个参数就没用了。</p>
<h4 id="KeepAliveTime"><a href="#KeepAliveTime" class="headerlink" title="KeepAliveTime"></a>KeepAliveTime</h4><p>非核心线程空闲时保持存活时间，即当线程没有任务执行时间时，继续存活的时间。</p>
<h4 id="unit"><a href="#unit" class="headerlink" title="unit"></a>unit</h4><p>线程保持活跃时间单位</p>
<h4 id="BlockingQueue-workQueue"><a href="#BlockingQueue-workQueue" class="headerlink" title="BlockingQueue workQueue"></a>BlockingQueue workQueue</h4><p>用于保存等待执行任务的阻塞队列。<a href="#常用的阻塞队列">BlockingQueue</a></p>
<h4 id="ThreadFactory"><a href="#ThreadFactory" class="headerlink" title="ThreadFactory"></a>ThreadFactory</h4><p>创建线程工厂</p>
<h4 id="RejectedExecutionHandler-handler：饱和策略"><a href="#RejectedExecutionHandler-handler：饱和策略" class="headerlink" title="RejectedExecutionHandler handler：饱和策略"></a>RejectedExecutionHandler handler：饱和策略</h4><p>当队列和最大线程池都满了之后的饱和策略</p>
<ul>
<li>CallerRunsPolicy : 调用线程处理任务</li>
<li>AbortPolicy : 抛出异常</li>
<li>DiscardPolicy : 直接丢弃</li>
<li>DiscardOldestPolicy : 丢弃队列中最老的任务，执行新任务</li>
</ul>
<h2 id="Daemon"><a href="#Daemon" class="headerlink" title="Daemon"></a>Daemon</h2><p>守护线程是程序运行时在 提供服务的线程，不属于程序中不可或缺部分。</p>
<p>当所有非守护线程结束，程序终止，同时回杀死所有守护线程。</p>
<h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h2><p>Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。</p>
<p>sleep() 可能会抛出 InterruptedException, 因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其他异常也同样需要再本地进行处理。</p>
<h2 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h2><p>对于静态方法 Thread.yield()的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其他线程来运行。</p>
<h1 id="三、中断"><a href="#三、中断" class="headerlink" title="三、中断"></a>三、中断</h1><p>一个线程执行完毕之后会自动结束，如果在运行过程中发生异常，也会提前结束。</p>
<h2 id="InterruptedEception"><a href="#InterruptedEception" class="headerlink" title="InterruptedEception"></a>InterruptedEception</h2><p>通过调用一个线程的 interrupt()来中断线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出InterruptedException，从而提前结束该线程。但是不能中断I/O 阻塞和 synchronized 锁阻塞。</p>
<p>下面先启动一个线程，然后在sleep的时候，中断它，就会抛出一个 InterruptedException，从而结束线程，不执行后面的语句。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(<span class="string">"thread run"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    thread.start();</span><br><span class="line">    thread.interrupt();</span><br><span class="line">    System.out.println(<span class="string">"main run"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main run</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">at java.lang.Thread.sleep(Native Method)</span><br><span class="line">at TestInterruptedException.lambda$main$<span class="number">0</span>(TestInterruptedException.java:<span class="number">17</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br></pre></td></tr></table></figure>



<h2 id="interrupted"><a href="#interrupted" class="headerlink" title="interrupted()"></a>interrupted()</h2><p>如果一个线程的 run() 方法执行一个无循环，并且没有执行sleep()等，会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使该线程提前结束。</p>
<p>但是调用 interrupt()方法会设置线程的中断标记，此时调用 inerrupted() 方法会返回 true。 因此可以在循环体重使用interrupted()方法来判断线程是否处于中断状态的，从而提前结束线程。</p>
<p>也就是说，这个方法在线程正常运行时，无法停止运行，只能给这个线程打个标记，申请中断了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (!Thread.interrupted())&#123;</span><br><span class="line">            System.out.println(<span class="string">"123"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"结束"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    thread.start();</span><br><span class="line">    thread.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Executor-的中断操作"><a href="#Executor-的中断操作" class="headerlink" title="Executor 的中断操作"></a>Executor 的中断操作</h2><p>调用 Executor 的  shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是shutdownNow()方法，则相当于调用每个线程的interrupt()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(<span class="string">"thread run"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    executorService.shutdownNow();</span><br><span class="line">    System.out.println(<span class="string">"main run"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">main run</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">	at java.lang.Thread.sleep(Native Method)</span><br><span class="line">	at ShutdownExecutor.lambda$main$<span class="number">0</span>(ShutdownExecutor.java:<span class="number">16</span>)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1149</span>)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">624</span>)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br></pre></td></tr></table></figure>

<p>如果只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future&lt;?&gt;对象，通过调用该对象的cancel(true)方法就可以中断该线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中断单个线程</span></span><br><span class="line">Future&lt;?&gt; submit = executorService.submit(() -&gt; &#123;&#125;);</span><br><span class="line">submit.cancel(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>



<h1 id="四、互斥同步"><a href="#四、互斥同步" class="headerlink" title="四、互斥同步"></a>四、互斥同步</h1><p>Java提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的synchronized， 而另一个是 JDK 实现的 ReentrantLock 。</p>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><ol>
<li><p>同步一个代码块</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会同步。</p>
<p>对于以下代码块，使用ExecutorService执行了两个线程。由于test1()调用的是同一个对象的同步代码块，所以是同步执行的，当一个线程进入时，另一个线程就在等待。而test2()调用的是不同对象的同步代码块，所以两个线程就不同步了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    test1(); <span class="comment">// 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 </span></span><br><span class="line">    test2(); <span class="comment">// 0 1 2 3 4 5 6 7 8 9 10 0 1 2 3 4 11 5 6 7 8 9 12 13 14 10 11 12 13 14 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SynchronizedDemo1 demo1 = <span class="keyword">new</span> SynchronizedDemo1();</span><br><span class="line">    SynchronizedDemo1 demo2 = <span class="keyword">new</span> SynchronizedDemo1();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; demo1.f1());</span><br><span class="line">    executorService.execute(() -&gt; demo2.f1());</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SynchronizedDemo1 synchronizedDemo1 = <span class="keyword">new</span> SynchronizedDemo1();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; synchronizedDemo1.f1());</span><br><span class="line">    executorService.execute(() -&gt; synchronizedDemo1.f1());</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>同步一个方法</p>
<p>和同步代码块一样，作用于一个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">func</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>同步一个类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (SynchronizedDemo<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会镜进行同步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    test3(); <span class="comment">// 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SynchronizedDemo2 demo1 = <span class="keyword">new</span> SynchronizedDemo2();</span><br><span class="line">    SynchronizedDemo2 demo2 = <span class="keyword">new</span> SynchronizedDemo2();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; demo1.f1());</span><br><span class="line">    executorService.execute(() -&gt; demo2.f1());</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedDemo2<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>同步一个静态方法</p>
<p>静态方法也是作用于整个类的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock是 java.util.concurrent (J.U.C) 包中的锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    ReentrantLockDemo reentrantLockDemo = <span class="keyword">new</span> ReentrantLockDemo();</span><br><span class="line">    executorService.execute(() -&gt; reentrantLockDemo.test());</span><br><span class="line">    executorService.execute(() -&gt; reentrantLockDemo.test());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>



<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><ol>
<li><p>锁的实现</p>
<p>synchronized是JVM实现的， 而ReentrantLock 是JDK 实现的。</p>
</li>
<li><p>性能</p>
<p>差不多。</p>
</li>
<li><p>等待可中断</p>
<p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。</p>
<p>ReentrantLock可以中断，而synchronized不行。</p>
</li>
<li><p>公平锁</p>
<p>公平锁，是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。</p>
<p>synchronized中的锁是非公平的， ReentrantLock默认情况下是非公平的，也可以是公平的。</p>
</li>
<li><p>锁绑定多个条件</p>
<p>一个ReentrantLock 可以同时绑定多个Condition 对象</p>
</li>
</ol>
<h2 id="使用选择"><a href="#使用选择" class="headerlink" title="使用选择"></a>使用选择</h2><p>除非需要使用ReentrantLock的高级功能，否则优先使用synchronized。这是因为，synchronized 是 JVM实现的一种锁机制， JVM 原生的支持它，而ReentrantLock不是所有的JDK版本都支持。并且使用 synchronized 不用担心没有实放锁而导致死锁的问题，因为JVM会确保锁的释放。</p>
<h1 id="五、线程之间的协作"><a href="#五、线程之间的协作" class="headerlink" title="五、线程之间的协作"></a>五、线程之间的协作</h1><p>当多个线程可以一起工作去解决某个问题的时候，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。</p>
<h2 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h2><p>在线程中调用另外一个线程的join()方法， 会将当前线程挂起，而不是忙等待，直到目标线程结束。</p>
<p>所以下面这个demo , 虽然b先启动，但是因为在 b线程中调用了a线程的join()方法，所以b线程会等a线程结束后才继续执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        B b = <span class="keyword">new</span> B(a);</span><br><span class="line"></span><br><span class="line">        b.start();</span><br><span class="line">        a.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"a"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.a = a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                a.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"b"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br></pre></td></tr></table></figure>

<h2 id="wait-notify-notifyAll"><a href="#wait-notify-notifyAll" class="headerlink" title="wait(), notify(), notifyAll()"></a>wait(), notify(), notifyAll()</h2><p>这几个方法都属于 Object ，而不是 Thread。</p>
<p>在使用wait() 挂起时，线程会释放锁。这是因为，如果没有释放锁，那么其他线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。</p>
<ul>
<li>wait()，将一个想要获取某个对象锁的线程，放到等待池中等待。</li>
<li>notify(), 随机将等待池中的某个线程，唤醒，移动到锁池中，参与竞争锁</li>
<li>notifyAll()， 将等待池中的所有线程唤醒，移动到锁池中</li>
</ul>
<p>只有在同步方法或者是同步代码块中使用，否则会在运行时抛出 IllegalMonitorStateException</p>
<p><strong>始终要在循环中调用wait方法；永远不要在循环之外调用它</strong>。</p>
<h2 id="awiat-、signal-、signalAll"><a href="#awiat-、signal-、signalAll" class="headerlink" title="awiat() 、signal() 、signalAll()"></a>awiat() 、signal() 、signalAll()</h2><p>java.util.concurrent 类库中提供了Condition 类来实现线程之间的协调，可以再Condition 上调用 await()方法使线程等待，其他线程调用 signal() 或 signalAll() 方法唤醒等待的线程。</p>
<p>相比于 wait()这种等待方式，await() 可以指定等待的条件，因此更加灵活。</p>
<p>使用Lock来获取一个Condition对象。</p>
<p>然后调Condition对象的 await()和signalAll()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AwaitSignalDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"before"</span>);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            condition.await();</span><br><span class="line">            System.out.println(<span class="string">"after"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        AwaitSignalDemo awaitSignalDemo = <span class="keyword">new</span> AwaitSignalDemo();</span><br><span class="line">        executorService.execute(awaitSignalDemo::after);</span><br><span class="line">        executorService.execute(awaitSignalDemo::before);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before</span><br><span class="line">after</span><br></pre></td></tr></table></figure>



<h1 id="六、线程的状态"><a href="#六、线程的状态" class="headerlink" title="六、线程的状态"></a>六、线程的状态</h1><p>线程状态，一个线程只能处于一种状态，并且这里的线程状态特指<strong>Java虚拟机的线程状态</strong>，不能反映线程在特定操作系统下的状态。</p>
<h2 id="新建-NEW"><a href="#新建-NEW" class="headerlink" title="新建(NEW)"></a>新建(NEW)</h2><p>创建后尚未启动</p>
<h2 id="可运行（RUNABLE）"><a href="#可运行（RUNABLE）" class="headerlink" title="可运行（RUNABLE）"></a>可运行（RUNABLE）</h2><p>正在Java虚拟机中运行。但是在操作系统层面，他可能处于运行状态，也可能等待资源调度（例如处理器资源），资源调度完成就 进入运行状态。所以该状态的可运行是指可以被运行，具体有没有运行要看底层操作系统的资源调度。</p>
<h2 id="阻塞（BLOCKED）"><a href="#阻塞（BLOCKED）" class="headerlink" title="阻塞（BLOCKED）"></a>阻塞（BLOCKED）</h2><p>请求获取 monitor lock 从而进入 synchronized 函数或者代码块，但是其他线程已经占用了该 monitor lock，所以处于阻塞状态。要结束该状态，从而进入 RUNABLE 需要其他线程释放 monitor lock。</p>
<h2 id="无限期等待（WAITING）"><a href="#无限期等待（WAITING）" class="headerlink" title="无限期等待（WAITING）"></a>无限期等待（WAITING）</h2><p>等待其他线程显式的唤醒。</p>
<p>阻塞和等待的区别在于，阻塞是被动的，被阻塞的线程是在等待获取 monitor lock。而等待是主动的，通过 Object.wait() 等方法进入。</p>
<table>
<thead>
<tr>
<th>进入方法</th>
<th>退出方法</th>
</tr>
</thead>
<tbody><tr>
<td>没有设置 Timeout 参数的 Object.wait() 方法</td>
<td>Object.notify()  、Object.notifyAll()</td>
</tr>
<tr>
<td>没有设置 Timeout 参数的 Thread.join() 方法</td>
<td>等待被调用的线程执行完毕</td>
</tr>
<tr>
<td>LockSupport.park() 方法</td>
<td>LockSupport.unpark(Thread)</td>
</tr>
</tbody></table>
<h2 id="限期等待（TIMED-WAITING）"><a href="#限期等待（TIMED-WAITING）" class="headerlink" title="限期等待（TIMED_WAITING）"></a>限期等待（TIMED_WAITING）</h2><p>无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒</p>
<table>
<thead>
<tr>
<th><strong>进入方法</strong></th>
<th>退出方法</th>
</tr>
</thead>
<tbody><tr>
<td>Thread.sleep() 方法</td>
<td>时间结束</td>
</tr>
<tr>
<td>设置Timeout参数的Object.wait()方法</td>
<td>时间结束、Object.notify()、Object.notifyAll()</td>
</tr>
<tr>
<td>设置了Timeout参数的Thread.join()方法</td>
<td>时间结束、被调用的线程执行完毕</td>
</tr>
<tr>
<td>LockSupport.parkNanos()方法</td>
<td>LockSupport.unpark(Thread)</td>
</tr>
<tr>
<td>LockSupport.parkUtil() 方法</td>
<td>LockSupport.unpark(Thread)</td>
</tr>
</tbody></table>
<p>调用 Thread.sleep()方法使线程进入限期等待状态时，常用”使一个线程随眠“进行描述。调用Object.wait()方法使线程进入限期等待或者无限期等待时，常用”挂起一个线程“进行描述。睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。</p>
<h2 id="死亡（TERMINATED）"><a href="#死亡（TERMINATED）" class="headerlink" title="死亡（TERMINATED）"></a>死亡（TERMINATED）</h2><p>可以是线程结束任务之后自己结束，或者产生异常而结束</p>
<h1 id="七、-J-U-C-AQS"><a href="#七、-J-U-C-AQS" class="headerlink" title="七、 J.U.C -AQS"></a>七、 J.U.C -AQS</h1><p>java.util.concurrent (J.U.C) 大大提高了并发性能，AQS被认为是 J.U.C 的核心。</p>
<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>倒数计时，用来控制一个或者多个线程等待多个线程。</p>
<p>维护了一个计数器cnt，每次调用 countDown() 方法会人计数器的值减1，减到0 的时候，那些因为调用await() 方法而在等待的线程就会被唤醒。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"ready"</span>);</span><br><span class="line">                countDownLatch.await();</span><br><span class="line">                System.out.println(<span class="string">"end"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(<span class="string">"one thread count .."</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当执行countDownLatch.countDown() = 设定次数时，调用 countDownLatch.await()的线程就会被唤醒</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ready</span><br><span class="line">one thread count ..</span><br><span class="line">one thread count ..</span><br><span class="line">one thread count ..</span><br><span class="line">one thread count ..</span><br><span class="line">one thread count ..</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>循环屏障，用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。</p>
<p>和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法后，计数器会减1，并进行等待，直到计数器为0，所有调用 await() 方法而在等待的线程才能继续执行。</p>
<p>CyclicBarrier 和CountDownLatch 的一个区别是，CyclicBarrier 的计数器是通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。</p>
<p>CyclicBarrier 有两个构造 函数， 其中parties 指示计数器的初始值，barrierAction在所有线程都到达屏障的时候会执行一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>demo 如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"ready..."</span>);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                    System.out.println(<span class="string">"go!"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ready...</span><br><span class="line">ready...</span><br><span class="line">ready...</span><br><span class="line">ready...</span><br><span class="line">ready...</span><br><span class="line">go!</span><br><span class="line">go!</span><br><span class="line">go!</span><br><span class="line">go!</span><br><span class="line">go!</span><br></pre></td></tr></table></figure>



<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。</p>
<p>以下demo模拟来了对某个服务的并发请求，每次只能有三个客户端同时访问，请求总和为10。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(<span class="string">"剩余数量"</span> + semaphore.availablePermits());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">剩余数量<span class="number">2</span></span><br><span class="line">剩余数量<span class="number">0</span></span><br><span class="line">剩余数量<span class="number">1</span></span><br><span class="line">剩余数量<span class="number">0</span></span><br><span class="line">剩余数量<span class="number">2</span></span><br><span class="line">剩余数量<span class="number">2</span></span><br><span class="line">剩余数量<span class="number">1</span></span><br><span class="line">剩余数量<span class="number">2</span></span><br><span class="line">剩余数量<span class="number">0</span></span><br><span class="line">剩余数量<span class="number">1</span></span><br></pre></td></tr></table></figure>



<h1 id="八、J-U-C-其他组件"><a href="#八、J-U-C-其他组件" class="headerlink" title="八、J.U.C - 其他组件"></a>八、J.U.C - 其他组件</h1><h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>在介绍Callable时 我们知道它可以有返回值，返回值通过 Future 进行封装。FutureTask 实现了RunnableFuture 接口，该接口继承自 Runnable和 Future 接口，这使得 FutureTask 既可以当做一个任务执行，也可以有返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>FutureTask可用于异步获取执行结果，或者是取消执行任务的场景。当一个计算任务需要执行很长时间时，那么就可以用FutureTask 来封装这个任务，主线程在完成自己的任务之后再去获取结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTaskDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; vFutureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                result = result + i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(vFutureTask);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        Thread otherThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"other task is running..."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        otherThread.start();</span><br><span class="line">        System.out.println(vFutureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">other task is running...</span><br><span class="line"><span class="number">4950</span></span><br></pre></td></tr></table></figure>



<h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p>java.util.concurrent.BlockingQueue 接口有以下阻塞队列实现</p>
<ul>
<li>FIFO 队列 ：LinkedBlockingQueue、ArrayBlockingQueue(固定长度)</li>
<li>优先级队列：PriorityBlockingQueue</li>
</ul>
<p>提供了阻塞的take()和 put() 方法： </p>
<p>如果队列为空 take()将阻塞，直到队列中有内容。</p>
<p>如果队列为满put()将阻塞，直到队列中有空闲位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread producter = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            String code = RandomStringUtils.randomNumeric(<span class="number">6</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                blockingQueue.put(code);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">"producer("</span> + code + <span class="string">").."</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread consumer = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            String take = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                take = blockingQueue.take();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">"consumer("</span> + take + <span class="string">")..."</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        executorService.execute(producter);</span><br><span class="line">        executorService.execute(producter);</span><br><span class="line">        executorService.execute(consumer);</span><br><span class="line">        executorService.execute(consumer);</span><br><span class="line">        executorService.execute(consumer);</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>队列中没有元素时，消费者会等待生产者生产，阻塞在这里。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Connected to the target VM, address: <span class="string">'127.0.0.1:0'</span>, transport: <span class="string">'socket'</span></span><br><span class="line">consumer(<span class="number">569389</span>)...producer(<span class="number">170545</span>)..consumer(<span class="number">170545</span>)...producer(<span class="number">569389</span>)..</span><br></pre></td></tr></table></figure>

<p>没有消费完，主线程还是正常结束</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Connected to the target VM, address: <span class="string">'127.0.0.1:0'</span>, transport: <span class="string">'socket'</span></span><br><span class="line">consumer(<span class="number">692109</span>)...consumer(<span class="number">884841</span>)...producer(<span class="number">124762</span>)..producer(<span class="number">884841</span>)..producer(<span class="number">692109</span>)..</span><br><span class="line">Disconnected from the target VM, address: <span class="string">'127.0.0.1:0'</span>, transport: <span class="string">'socket'</span></span><br></pre></td></tr></table></figure>

<h3 id="常用的阻塞队列："><a href="#常用的阻塞队列：" class="headerlink" title="常用的阻塞队列："></a>常用的阻塞队列：</h3><ol>
<li>*<em>SynchronousQueue *</em>:  同步移交队列，适用于非常大的或者无界的线程池，可以避免任务排队。SynchronousQueue 队列接收到任务后，会直接将任务从生产者移交给工作线程，这种移交机制高校。只有当线程池是无界的或者可以拒绝任务时，使用SynchronousQueue队列才有意义。要将一个元素放入SynchronousQueue，就需要有另一个线程才等待接收者这个元素，如果没有线程在等待，要么新建一个线程，要么拒绝掉。<code>newCachedThreadPool</code>默认使用的就是这种同步移交队列。吞吐量高约 LinkedBlockingQueue。</li>
<li><strong>LinkedBlockingQueue</strong>: 基于链表结构的阻塞队列，FIFO 原则排序。当任务提交过来时，如果线程数小于核心线程数则等待，大于的时候就进入工作队列进行等待。LinkedBlockingQueue队列没有最大值限制，只要任务数超过核心线程，都会被添加到队列中，这就会导致，总线程数永远不会超过核心线程数，所以这个时候 maximumPoolSize就没意义了。 <code>newFixedThreadPool</code>和<code>newSingleThreadPool</code>默认使用的是 无界的 LinkedBlockingQueue队列。吞吐量高于 ArrayBlockingQueue</li>
<li><strong>ArrayBlockingQueue</strong> : 基于数组结构的 有界阻塞队列，可以设置队列上限值，FIFO原则排序。当任务提交过来时，如果线程数小于核心线程数则等待；大于的时候就进入工作队列进行等待；如果队列也满了，则创建非核心线程执行任务；如果总线程达到了 maximumPoolSize，则根据饱和策略去拒绝。</li>
<li><strong>DelayQueue</strong> :  延迟队列，队列中的元素必须实现 Delayed 接口。当任务体骄傲时，入队列只有达到指定的延时时间，才会执行任务。</li>
<li><strong>PriorityBlockingQueue</strong>：优先级阻塞队列，根据优先级执行任务，优先级是通过自然排序或者是Comparator定义实现。</li>
</ol>
<h2 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h2><p>主要用于并行计算中，和MapReduce 原理类似，都是把大的计算任务拆分成多个小任务并行计算。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinDemo</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threshold = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> first;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> last;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinDemo</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (last - first &lt;= threshold) &#123;</span><br><span class="line">            <span class="comment">// 直接计算</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = first; i &lt;= last; i++) &#123;</span><br><span class="line">                result += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 拆分任务</span></span><br><span class="line">            <span class="keyword">int</span> middle = first + (last - first) / <span class="number">2</span>;</span><br><span class="line">            ForkJoinDemo leftTask = <span class="keyword">new</span> ForkJoinDemo(first, middle);</span><br><span class="line">            ForkJoinDemo rightTask = <span class="keyword">new</span> ForkJoinDemo(middle + <span class="number">1</span>, last);</span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line">            result = leftTask.join() + rightTask.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        ForkJoinDemo forkJoinDemo = <span class="keyword">new</span> ForkJoinDemo(<span class="number">1</span>, <span class="number">10000</span>);</span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        ForkJoinTask&lt;Integer&gt; submit = forkJoinPool.submit(forkJoinDemo);</span><br><span class="line">        System.out.println(submit.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ForkJoin 使用ForkJoinPool 来启动， 是一个特殊的线程池，线程数量取决于CPU核数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class ForkJoinPool extends AbstractExecutorService</span><br></pre></td></tr></table></figure>

<p>ForkJoinPool 实现了工作窃取算法（workSteal）来提高CPU 的利用率。每个线程都维护了一个双端队列，用来存储需要执行的任务。工作窃取算法，允许空闲的线程从其他线程的双端队列中窃取一个任务来执行。窃取的任务必须是最晚的任务，避免和队列所属线程发生竞争。</p>
<h1 id="九、线程不安全示例"><a href="#九、线程不安全示例" class="headerlink" title="九、线程不安全示例"></a>九、线程不安全示例</h1><p>多个线程对同一个共享数据进行访问，而不采取同步操作的话，那么结果很容易出问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadUnsafeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeIncrementDemo</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeIncrementDemo</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> AtomicInteger cnt = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cnt.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cnt.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        UnsafeIncrementDemo unsafeIncrementDemo = <span class="keyword">new</span> UnsafeIncrementDemo();</span><br><span class="line">        SafeIncrementDemo safeIncrementDemo = <span class="keyword">new</span> SafeIncrementDemo();</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1000</span>);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                unsafeIncrementDemo.add();</span><br><span class="line">                safeIncrementDemo.add();</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">"unsafeIncrementDemo:"</span> + unsafeIncrementDemo.get());</span><br><span class="line">        System.out.println(<span class="string">"safeIncrementDemo:"</span> + safeIncrementDemo.get());</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsafeIncrementDemo:<span class="number">986</span></span><br><span class="line">safeIncrementDemo:<span class="number">1000</span></span><br></pre></td></tr></table></figure>



<h1 id="十、Java-内存模型"><a href="#十、Java-内存模型" class="headerlink" title="十、Java 内存模型"></a>十、Java 内存模型</h1><p>Java 内存模型，试图屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各个平台下都能达到一致的内存访问效果。</p>
<h2 id="主内存-和-工作内存"><a href="#主内存-和-工作内存" class="headerlink" title="主内存 和 工作内存"></a>主内存 和 工作内存</h2><p>处理上的寄存器比内存快了多个数量级，所以引入了高速缓存。由此引发了新的问题，缓存一致性。如果多个缓存共享同一块主内存区域，那么多个缓存数据可能会不一致，需要一些协议来解决问题。 </p>
<p>开发中，所有的变量都存在主内存中，每个线程还有自己的工作内存，工作内存存储在高速缓存或者寄存器中，保存了该线程使用的变量的主内存副本拷贝。</p>
<p>线程只能通过操作工作内存中的变量，不同线程见的变量值传递需要通过主内存。</p>
<h2 id="内存间的交互操作"><a href="#内存间的交互操作" class="headerlink" title="内存间的交互操作"></a>内存间的交互操作</h2><p>Java的内存中定义了8个操作，来完成工作内存和主内存之间的交互操作:</p>
<ul>
<li>read : 把一个变量从主内存传输到工作内存中</li>
<li>load : 在read之后执行，把read得到的值放入工作内存的变量副本中。</li>
<li>use : 把工作内存中的一个变量的值传递给执行引擎</li>
<li>assign : 把一个从执行引擎接收到的值赋给工作内存的变量</li>
<li>store：把工作内存的一个变量的值传送到主内存中</li>
<li>write：在store之后执行，把store得到的值写放入主内存的变量中。</li>
<li>lock：作用于主内存的变量</li>
<li>unlock：同上</li>
</ul>
<h2 id="内存模型三大特性"><a href="#内存模型三大特性" class="headerlink" title="内存模型三大特性"></a>内存模型三大特性</h2><h3 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1.原子性"></a>1.原子性</h3><p>Java 内存模型保证了read、load、use、assign、store、write、lock和unlock操作具有原子性，例如对一个int变量执行assign赋值操作，这个操作就是原子性的。但是Java内存模型允许虚拟机将没有被volatile修饰的64位数据（long,double）的读写操作划分为两次32位的操作来进行，既load、store、read和write操作可以不具备原子性。</p>
<h3 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2.可见性"></a>2.可见性</h3><p>可见性指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。Java内存模型是通过在变量修改后将心值同步回内存，在变量读取前从内存刷新 变量值来实现可见性的。</p>
<p>主要有三种实现方式：</p>
<ul>
<li>volatile</li>
<li>synchronized, 对一个变量执行unlock操作前，必须把变量同步回主内存。</li>
<li>final , 被final关键词修饰的字段在构造器中一旦初始化完成，并且没有发生this 逃逸 （其他线程通过this引用访问到初始化了一半的对象），那么其他线程就能看见final字段的值。</li>
</ul>
<h3 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3.有序性"></a>3.有序性</h3><p>有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有的操作都是无序的，无序是因为发生了指令重排。在Java内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程 程序的执行，但是会影响到多线程并发执行 正确性。</p>
<p>volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。</p>
<p>也可以通过 synchronized 来保证有序性, 它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码块。</p>
<h2 id="先行先发原则"><a href="#先行先发原则" class="headerlink" title="先行先发原则"></a>先行先发原则</h2><p>除了可以用volatile和synchronized来强行保证有序性之外，JVM 还规定了先行先发原则，让一个操作无需控制就先于另一个操作完成。</p>
<h4 id="1-单一线程原则"><a href="#1-单一线程原则" class="headerlink" title="1. 单一线程原则"></a>1. 单一线程原则</h4><blockquote>
<p>Single Thread rule </p>
</blockquote>
<p>在一个线程内，在程序前面的操作先行发生于后面的操作。</p>
<h4 id="2-管程锁定规则"><a href="#2-管程锁定规则" class="headerlink" title="2. 管程锁定规则"></a>2. 管程锁定规则</h4><blockquote>
<p>Monitor Lock Rule </p>
</blockquote>
<p>一个unlock操作先行发生于后面对同一个锁的lock 操作。</p>
<h4 id="3-volatile-变量规则"><a href="#3-volatile-变量规则" class="headerlink" title="3. volatile 变量规则"></a>3. volatile 变量规则</h4><blockquote>
<p>Volatile Variable Rule</p>
</blockquote>
<p>对一个volatile 变量的写操作先行发生于后面对这个变量的读操作。</p>
<h4 id="4-线程启动规则"><a href="#4-线程启动规则" class="headerlink" title="4. 线程启动规则"></a>4. 线程启动规则</h4><blockquote>
<p>Thread Start Rule</p>
</blockquote>
<p>Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。</p>
<h4 id="5-线程加入规则"><a href="#5-线程加入规则" class="headerlink" title="5. 线程加入规则"></a>5. 线程加入规则</h4><blockquote>
<p>Thread Join Rule</p>
</blockquote>
<p>Thread 对象的结束先行发生于 join() 方法返回。</p>
<h4 id="6-线程中断规则"><a href="#6-线程中断规则" class="headerlink" title="6. 线程中断规则"></a>6. 线程中断规则</h4><blockquote>
<p>Thread Interruption Rule</p>
</blockquote>
<p>对线程interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过interrupted()方法检测到是否有中断发生。</p>
<h4 id="7-对象终结规则"><a href="#7-对象终结规则" class="headerlink" title="7. 对象终结规则"></a>7. 对象终结规则</h4><blockquote>
<p>Finalizer Rule </p>
</blockquote>
<p>一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize() 方法的开始。</p>
<h4 id="8-传递性"><a href="#8-传递性" class="headerlink" title="8. 传递性"></a>8. 传递性</h4><blockquote>
<p>Transitivity </p>
</blockquote>
<p>如果操作A 先行发生于操作B， 操作B先行发生于操作C，那么操作A先行发生于操作C。</p>
<h1 id="十一、线程安全"><a href="#十一、线程安全" class="headerlink" title="十一、线程安全"></a>十一、线程安全</h1><p>多个线程不管以何种方式访问某个类，并且再主调代码中不需要进行同步，都能表现正确的行为。</p>
<p>线程安全有以下几种实现方式：</p>
<h2 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h2><p>不可变（Immutable）的对象一定是线程安全的，不需要再采取安全保障措施。</p>
<h2 id="互斥同步-阻塞同步"><a href="#互斥同步-阻塞同步" class="headerlink" title="互斥同步/阻塞同步"></a>互斥同步/阻塞同步</h2><p>synchronized 和 ReentrantLock</p>
<h2 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h2><h3 id="1-CAS"><a href="#1-CAS" class="headerlink" title="1. CAS"></a>1. CAS</h3><p>乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是：比较并交换（Compare-and-Swap，CAS）。CAS指令需要有3个操作数，分别是内存地址V、旧的预期值A和新值B。当执行操作时，只有当V的值等于A，才将V的值更新为B。</p>
<h3 id="2-AtomicInteger"><a href="#2-AtomicInteger" class="headerlink" title="2. AtomicInteger"></a>2. AtomicInteger</h3><p>J.U.C 包里面 的整数原子类AtomicInteger 的方法调用了Unsafe类的CAS操作。</p>
<p>以下代码使用了AtomicInteger执行了自增的操作。</p>

        </div>
        <!-- Comments -->
        
    

    

    

    
    
<section class="comments" id="comments">
    <div id="gitalk-container"></div>
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script type="text/javascript">
        var gitalk = new Gitalk({
            clientID: '',
            clientSecret: '',
            id: window.location.pathname,
            repo: 'comment',
            owner: 'hhyouyou',
            admin: 'hhyouyou'
        })
        gitalk.render('gitalk-container')
    </script>
</section>


    

    

    


      </div>
    </div>
  </div>
</article>



    
<!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
        &copy;  2021
        <span class="with-love">
            <i class="fa fa-heart"></i>
        </span>
        <span class="author">djx</span>

        
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
        

        
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <p class="visit-statistics">
            <span id="busuanzi_container_site_pv">
              本站总访问：<span id="busuanzi_value_site_pv"></span>次
              &nbsp;&nbsp;&nbsp;&nbsp;
            </span>
        <p>
        
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->

<script src="/js/highlight.pack.js"></script>

<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>



  </body>
</html>

